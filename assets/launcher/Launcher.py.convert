#!/usr/bin/env python3
"""
Launcher.py - Game Launcher Script
A Python port of the Launcher.ahk script for launching games with pre/post actions
"""

import os
import sys
import subprocess
import configparser
import time
import ctypes
import platform
import shutil
import tempfile
import signal
import psutil
from pathlib import Path
import winreg
import win32gui
import win32con
import win32process
import win32api
from typing import Dict, List, Optional, Tuple, Union

def find_path_case_insensitive(path: str) -> Optional[str]:
    """
    Find a file or directory with case-insensitive matching.
    Returns the actual path if found, None otherwise.
    """
    if not path:
        return None
    
    # If the path exists as-is, return it
    if os.path.exists(path):
        return path
    
    # Split the path into components
    path_obj = Path(path)
    parts = path_obj.parts
    
    # Start with the root (drive letter on Windows, / on Unix)
    if len(parts) == 0:
        return None
    
    # Build the path component by component with case-insensitive matching
    current_path = parts[0]
    
    # For Windows drive letters, ensure we have the backslash
    if len(current_path) == 2 and current_path[1] == ':':
        current_path = current_path + '\\'
    
    for part in parts[1:]:
        if not os.path.exists(current_path):
            return None
        
        # List items in current directory
        try:
            items = os.listdir(current_path)
        except (PermissionError, OSError):
            return None
        
        # Find matching item (case-insensitive)
        found = False
        for item in items:
            if item.lower() == part.lower():
                current_path = os.path.join(current_path, item)
                found = True
                break
        
        if not found:
            return None
    
    return current_path if os.path.exists(current_path) else None

class GameLauncher:
    def __init__(self):
        # Initialize variables
        self.home = os.path.dirname(os.path.abspath(__file__))
        self.source = os.path.join(self.home, "Python")
        self.binhome = os.path.join(self.home, "bin")
        self.curpidf = os.path.join(self.home, "rjpids.ini")
        self.current_pid = os.getpid()
        self.multi_instance = 0
        self.game_path = ""
        self.game_name = ""
        self.game_dir = ""
        self.plink = ""
        self.scpath = ""
        self.scextn = ""
        self.exe_list = ""
        self.joymessage = "No joysticks detected"
        self.joycount = 0
        self.mapper_extension = "gamecontroller.amgp"  # Default for antimicrox
        
        # Get command line arguments
        self.parse_arguments()
        
        # Check if we're running as admin
        self.is_admin = self.check_admin()
        
        # Set up message display
        self.setup_message_display()
        
        # Check for other instances
        if not self.check_instances():
            sys.exit(0)
        
        # Load configuration
        self.load_config()
        
        # Initialize joystick detection
        self.detect_joysticks()

    def parse_arguments(self):
        """Parse command line arguments"""
        if len(sys.argv) > 1:
            self.plink = sys.argv[1]
            
            # Get file extension
            _, self.scpath, self.scextn, self.game_name = self.split_path(self.plink)
            
            # Display message
            self.show_message(f"Launching: {self.plink}")
        else:
            self.show_message("No Item Detected")
            time.sleep(3)
            sys.exit(0)
    
    def check_admin(self):
        """Check if running as administrator"""
        try:
            if platform.system() == 'Windows':
                return ctypes.windll.shell32.IsUserAnAdmin() != 0
            else:
                return os.geteuid() == 0
        except:
            return False
    
    def setup_message_display(self):
        """Set up message display (tooltip or console)"""
        # For now, just use print. In a full implementation, 
        # this could be a small GUI window or system notification
        pass
    
    def show_message(self, message):
        """Show a message to the user"""
        print(message)
        # In a full implementation, this could update a GUI or show a notification
    
    def check_instances(self):
        """Check for other instances of the launcher"""
        if os.path.exists(self.curpidf):
            config = configparser.ConfigParser()
            config.read(self.curpidf)
            
            try:
                instance_pid = int(config.get('Instance', 'pid', fallback='0'))
                self.multi_instance = int(config.get('Instance', 'multi_instance', fallback='0'))
                
                if self.multi_instance == 1:
                    return True
                
                # Check if the process is still running
                if instance_pid != 0 and instance_pid != self.current_pid:
                    try:
                        process = psutil.Process(instance_pid)
                        if process.is_running():
                            # Ask user if they want to terminate the running instance

                            response = input("Would you like to terminate the running instance? (y/n): ")
                            if response.lower() == 'y':
                                process.terminate()
                                time.sleep(1)
                                if process.is_running():
                                    process.kill()
                            else:
                                return False
                    except psutil.NoSuchProcess:
                        pass  # Process doesn't exist, continue
            except Exception as e:
                pass
        
        return True
    
    def load_config(self):
        """Load configuration from Game.ini"""
        # First check if there's a Game.ini in the same directory as the shortcut
        game_ini = os.path.join(self.scpath, "Game.ini")
        
        if not os.path.exists(game_ini):
            # Fall back to config.ini in the home directory
            game_ini = os.path.join(self.home, "config.ini")
        
        if not os.path.exists(game_ini):
            self.show_message("No configuration file found")
            return
        
        config = configparser.ConfigParser()
        config.read(game_ini)
        
        # Load game information
        if 'Game' in config:
            self.game_path = config.get('Game', 'Executable', fallback='')
            self.game_dir = config.get('Game', 'Directory', fallback='')
            self.game_name = config.get('Game', 'Name', fallback=self.game_name)
        
        # Load paths
        if 'Paths' in config:
            self.controller_mapper_app = config.get('Paths', 'ControllerMapperApp', fallback='')
            self.borderless_app = config.get('Paths', 'BorderlessWindowingApp', fallback='')
            self.multimonitor_tool = config.get('Paths', 'MultiMonitorTool', fallback='')
            self.player1_profile = config.get('Paths', 'Player1Profile', fallback='')
            self.player2_profile = config.get('Paths', 'Player2Profile', fallback='')
            self.mm_game_config = config.get('Paths', 'MultiMonitorGamingConfig', fallback='')
        
        # Load options
        if 'Options' in config:
            self.run_as_admin = config.get('Options', 'RunAsAdmin', fallback='0') == '1'
            self.hide_taskbar = config.get('Options', 'HideTaskbar', fallback='0') == '1'
            self.borderless = config.get('Options', 'Borderless', fallback='0')
            self.use_kill_list = config.get('Options', 'UseKillList', fallback='0') == '1'
        
        # Load pre-launch apps
        if 'PreLaunch' in config:
            self.pre_launch_app_1 = config.get('PreLaunch', 'App1', fallback='')
            self.pre_launch_app_2 = config.get('PreLaunch', 'App2', fallback='')
            self.pre_launch_app_3 = config.get('PreLaunch', 'App3', fallback='')
            self.pre_launch_app_1_wait = config.get('PreLaunch', 'App1Wait', fallback='0') == '1'
            self.pre_launch_app_2_wait = config.get('PreLaunch', 'App2Wait', fallback='0') == '1'
            self.pre_launch_app_3_wait = config.get('PreLaunch', 'App3Wait', fallback='0') == '1'
        
        # Load post-launch apps
        if 'PostLaunch' in config:
            self.post_launch_app_1 = config.get('PostLaunch', 'App1', fallback='')
            self.post_launch_app_2 = config.get('PostLaunch', 'App2', fallback='')
            self.post_launch_app_3 = config.get('PostLaunch', 'App3', fallback='')
            self.post_launch_app_1_wait = config.get('PostLaunch', 'App1Wait', fallback='0') == '1'
            self.post_launch_app_2_wait = config.get('PostLaunch', 'App2Wait', fallback='0') == '1'
            self.post_launch_app_3_wait = config.get('PostLaunch', 'App3Wait', fallback='0') == '1'
            self.just_after_launch_app = config.get('PostLaunch', 'JustAfterLaunchApp', fallback='')
            self.just_before_exit_app = config.get('PostLaunch', 'JustBeforeExitApp', fallback='')
            self.just_after_launch_wait = config.get('PostLaunch', 'JustAfterLaunchWait', fallback='0') == '1'
            self.just_before_exit_wait = config.get('PostLaunch', 'JustBeforeExitWait', fallback='0') == '1'
        
        # Load sequences
        if 'Sequences' in config:
            # Get launch sequence
            launch_sequence_str = config.get('Sequences', 'LaunchSequence', fallback='')
            if launch_sequence_str:
                self.launch_sequence = launch_sequence_str.split(',')
            else:
                # Default launch sequence
                self.launch_sequence = [
                    "Controller-Mapper", 
                    "Monitor-Config", 
                    "No-TB", 
                    "Pre1", 
                    "Pre2", 
                    "Pre3", 
                    "Borderless"
                ]
            
            # Get exit sequence
            exit_sequence_str = config.get('Sequences', 'ExitSequence', fallback='')
            if exit_sequence_str:
                self.exit_sequence = exit_sequence_str.split(',')
            else:
                # Default exit sequence
                self.exit_sequence = [
                    "Post1", 
                    "Post2", 
                    "Post3", 
                    "Monitor-Config", 
                    "Taskbar",
                    "Controller-Mapper"
                ]
    
    def detect_joysticks(self):
        """Detect connected joysticks"""
        try:
            import pygame
            pygame.init()
            pygame.joystick.init()
            
            self.joycount = pygame.joystick.get_count()
            if self.joycount > 0:
                self.joymessage = f"{self.joycount} joysticks detected"
                
                # Initialize each joystick
                for i in range(self.joycount):
                    joystick = pygame.joystick.Joystick(i)
                    joystick.init()

            else:
                self.joymessage = "No joysticks detected"
            
            pygame.quit()
        except ImportError:
            self.joymessage = "Pygame not installed, joystick detection disabled"
        except Exception as e:
            self.joymessage = f"Error detecting joysticks: {e}"
    
    def run_pre_launch_apps(self):
        """Run pre-launch applications"""
        self.show_message("Running pre-launch applications")
        
        # Run pre-launch app 1
        app1 = find_path_case_insensitive(self.pre_launch_app_1)
        if app1:
            self.run_process(app1, wait=self.pre_launch_app_1_wait)
        
        # Run pre-launch app 2
        app2 = find_path_case_insensitive(self.pre_launch_app_2)
        if app2:
            self.run_process(app2, wait=self.pre_launch_app_2_wait)
        
        # Run pre-launch app 3
        app3 = find_path_case_insensitive(self.pre_launch_app_3)
        if app3:
            self.run_process(app3, wait=self.pre_launch_app_3_wait)
        
        # Set up multi-monitor configuration if specified
        mm_tool = find_path_case_insensitive(self.multimonitor_tool)
        mm_config = find_path_case_insensitive(self.mm_game_config)
        if mm_tool and mm_config:
            self.run_process(f'"{mm_tool}" /load "{mm_config}"', wait=True)
        
        # Set up controller mapper if specified
        mapper_app = find_path_case_insensitive(self.controller_mapper_app)
        p1_profile = find_path_case_insensitive(self.player1_profile)
        if mapper_app and p1_profile:
            # Determine which mapper we're using
            mapper_name = os.path.basename(mapper_app).lower()
            
            if "antimicro" in mapper_name:
                # For AntiMicroX
                cmd = f'"{mapper_app}" --tray --hidden --profile "{p1_profile}"'
                p2_profile = find_path_case_insensitive(self.player2_profile)
                if p2_profile:
                    cmd += f' --next --profile-controller 2 --profile "{p2_profile}"'
                self.run_process(cmd)
            elif "joyxoff" in mapper_name:
                # For JoyXoff
                self.run_process(f'"{mapper_app}" -load "{p1_profile}"')
            elif "joy2key" in mapper_name:
                # For Joy2Key
                self.run_process(f'"{mapper_app}" -load "{p1_profile}"')
            elif "keysticks" in mapper_name:
                # For KeySticks
                self.run_process(f'"{mapper_app}" -load "{p1_profile}"')
    
    def run_game(self):
        """Run the main game executable"""
        self.show_message(f"Launching game: {self.game_name}")
        
        # Prepare the command
        if not self.game_path:
            self.game_path = self.plink
        
        # Get the game directory
        if not self.game_dir:
            self.game_dir = os.path.dirname(self.game_path)
        
        # Resolve paths case-insensitively
        game_path = find_path_case_insensitive(self.game_path)
        game_dir = find_path_case_insensitive(self.game_dir)
        
        if not game_path:
            self.show_message(f"Game executable not found: {self.game_path}")
            return
        
        # Run the game
        if self.run_as_admin and platform.system() == 'Windows' and not self.is_admin:
            # Use PowerShell to run as admin
            cmd = f'powershell -Command "Start-Process \'{game_path}\' -Verb RunAs"'
            self.game_process = self.run_process(cmd, cwd=game_dir)
        else:
            self.game_process = self.run_process(f'"{game_path}"', cwd=game_dir)
        
        # Run just after launch app if specified
        just_after = find_path_case_insensitive(self.just_after_launch_app)
        if just_after:
            self.run_process(just_after, wait=self.just_after_launch_wait)
        
        # If borderless windowing is enabled, run it
        borderless = find_path_case_insensitive(self.borderless_app)
        if self.borderless in ['E', 'K'] and borderless:
            self.run_process(borderless)
        
        # Wait for the game to exit
        if self.game_process:
            self.game_process.wait()
    
    def run_post_launch_apps(self):
        """Run post-launch applications"""
        self.show_message("Running post-launch applications")
        
        # Run just before exit app if specified
        just_before = find_path_case_insensitive(self.just_before_exit_app)
        if just_before:
            self.run_process(just_before, wait=self.just_before_exit_wait)
        
        # Kill borderless windowing if specified
        if self.borderless == 'K' and self.borderless_app:
            self.kill_process(os.path.basename(self.borderless_app))
        
        # Run post-launch app 1
        if self.post_launch_app_1 and os.path.exists(self.post_launch_app_1):
            self.run_process(self.post_launch_app_1, wait=self.post_launch_app_1_wait)
        
        # Run post-launch app 2
        if self.post_launch_app_2 and os.path.exists(self.post_launch_app_2):
            self.run_process(self.post_launch_app_2, wait=self.post_launch_app_2_wait)
        
        # Run post-launch app 3
        if self.post_launch_app_3 and os.path.exists(self.post_launch_app_3):
            self.run_process(self.post_launch_app_3, wait=self.post_launch_app_3_wait)
    
    def cleanup(self):
        """Clean up processes and restore settings"""
        self.show_message("Cleaning up")
        
        # Kill controller mapper if running
        if self.controller_mapper_app:
            self.kill_process(os.path.basename(self.controller_mapper_app))
        
        # Restore multi-monitor configuration if needed
        # This would typically restore the desktop monitor configuration
        
        # Kill any remaining processes in the kill list if enabled
        if self.use_kill_list:
            self.kill_processes_in_list()
    
    def run(self):
        """Main execution flow"""
        try:
            # Write current PID to the PID file
            self.write_pid_file()
            
            # Run pre-launch applications
            self.run_pre_launch_apps()
            
            # Run the game
            self.run_game()
            
            # Run post-launch applications
            self.run_post_launch_apps()
            
            # Clean up
            self.cleanup()
            
        except Exception as e:
            self.show_message(f"Error: {e}")
        finally:
            self.show_message("Exiting launcher")
    
    # Helper methods
    def split_path(self, path):
        """Split a path into components (similar to SplitPath in AHK)"""
        p = Path(path)
        return str(p), str(p.parent), p.suffix.lstrip('.'), p.stem
    
    def run_process(self, cmd, cwd=None, wait=False, hide=False):
        """Run a process with the given command"""
        try:
            # Set up process creation flags
            creation_flags = 0
            if platform.system() == 'Windows' and hide:
                creation_flags = subprocess.CREATE_NO_WINDOW
            
            # Run the process
            process = subprocess.Popen(
                cmd, 
                cwd=cwd, 
                shell=True, 
                creationflags=creation_flags if platform.system() == 'Windows' else 0
            )
            
            # Wait for the process to complete if requested
            if wait:
                process.wait()
                return None
            
            return process
        except Exception as e:
            self.show_message(f"Error running process: {e}")
            return None
    
    def kill_process(self, process_name):
        """Kill a process by name"""
        try:
            for proc in psutil.process_iter(['pid', 'name']):
                if process_name.lower() in proc.info['name'].lower():
                    proc.terminate()
                    time.sleep(1)
                    if proc.is_running():
                        proc.kill()
        except Exception as e:
            self.show_message(f"Error killing process {process_name}: {e}")
    
    def kill_processes_in_list(self):
        """Kill processes in the kill list"""
        # This would be implemented based on your specific kill list logic
        pass
    
    def write_pid_file(self):
        """Write the current PID to the PID file"""
        config = configparser.ConfigParser()
        
        # Read existing file if it exists
        if os.path.exists(self.curpidf):
            config.read(self.curpidf)
        
        # Ensure sections exist
        if 'Instance' not in config:
            config['Instance'] = {}
        
        # Update PID
        config['Instance']['pid'] = str(self.current_pid)
        config['Instance']['multi_instance'] = str(self.multi_instance)
        
        # Write to file
        with open(self.curpidf, 'w') as f:
            config.write(f)

# Entry point
if __name__ == "__main__":
    launcher = GameLauncher()
    launcher.run()
