# [RJ_PROJ] Plugin System

## Overview

The plugin system provides a modular, extensible architecture for integrating external tools into [RJ_PROJ]. Plugins encapsulate tool-specific logic, configuration, and command building, making it easy to add new tools without modifying core code.

## Architecture

### Core Components

1. **ToolPlugin** (`base_plugin.py`): Abstract base class for all plugins
2. **ToolRegistry** (`registry.py`): Central registry for managing plugins
3. **PluginManager** (`managers/plugin_manager.py`): Integration layer with existing code
4. **Built-in Plugins** (`builtin/`): Default plugins shipped with [RJ_PROJ]

### Plugin Lifecycle

```
1. Plugin Definition → 2. Registration → 3. Discovery → 4. Configuration → 5. Execution
```

## Creating a Plugin

### Basic Structure

```python
from plugins.base_plugin import (
    ToolPlugin, PluginMetadata, ConfigField, CommandTemplate,
    PluginCategory, FieldType
)

class MyToolPlugin(ToolPlugin):
    def get_metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name="mytool",
            display_name="My Tool",
            category=PluginCategory.CUSTOM,
            version="1.0.0",
            description="Description of my tool"
        )
    
    def define_config_fields(self) -> List[ConfigField]:
        return [
            ConfigField(
                name="app_path",
                field_type=FieldType.FILE,
                label="My Tool Executable",
                required=True,
                filter="Executables (*.exe)"
            ),
        ]
    
    def define_commands(self) -> Dict[str, CommandTemplate]:
        return {
            'launch': CommandTemplate(
                template='"{app_path}" {options}',
                required_fields=['app_path'],
                optional_fields=['options']
            ),
        }
    
    def get_executable_patterns(self) -> List[str]:
        return ["mytool.exe"]
    
    def get_download_info(self) -> Optional[Dict[str, str]]:
        return {
            'url': 'https://example.com/mytool.7z',
            'extract_dir': 'bin/mytool',
        }
```

### Configuration Fields

Plugins define configuration fields that map to UI elements:

- **FILE**: File path selector
- **DIRECTORY**: Directory path selector
- **STRING**: Text input
- **BOOLEAN**: Checkbox
- **INTEGER**: Number input
- **LIST**: Multiple choice

### Command Templates

Command templates define how to build command-line invocations:

```python
CommandTemplate(
    template='"{app_path}" --flag "{profile}"',
    required_fields=['app_path', 'profile'],
    optional_fields=['options', 'arguments'],
    wait=False,  # Wait for process to complete
    hide=False   # Hide console window
)
```

### Advanced Command Building

Override `build_command()` for complex logic:

```python
def build_command(self, action: str, config: Dict[str, Any]) -> Optional[str]:
    if action == 'launch':
        cmd = f'"{config["app_path"]}"'
        
        # Conditional logic
        if config.get('enable_feature'):
            cmd += ' --feature'
        
        # Dynamic arguments
        if config.get('player2_profile'):
            cmd += f' --p2 "{config["player2_profile"]}"'
        
        return cmd
    
    return None
```

## Registering Plugins

### Built-in Plugins

Add to `builtin/__init__.py`:

```python
from .mytool_plugin import MyToolPlugin

__all__ = ['MyToolPlugin']
```

Register in `PluginManager._register_builtin_plugins()`:

```python
def _register_builtin_plugins(self):
    builtin_plugins = [
        AntiMicroXPlugin(),
        BorderlessPlugin(),
        MyToolPlugin(),  # Add here
    ]
    
    for plugin in builtin_plugins:
        self.registry.register(plugin)
```

### External Plugins

Place plugin files in a plugins directory and use auto-discovery:

```python
plugin_manager.registry.discover_plugins('/path/to/plugins')
```

## Using Plugins

### In Application Code

```python
from managers.plugin_manager import PluginManager

# Initialize
pm = PluginManager(app_root_dir)

# Get plugin
plugin = pm.get_registry().get('antimicrox')

# Build command
config = {
    'app_path': '/path/to/antimicrox.exe',
    'player1_profile': '/path/to/profile.amgp',
}
command = plugin.build_command('launch', config)

# Execute
subprocess.Popen(command, shell=True)
```

### Backward Compatibility

The plugin system integrates seamlessly with existing code:

```python
# Get repos.set-compatible data
repos_dict = plugin_manager.get_all_repos_dict()

# Merge with existing repos.set
merged = plugin_manager.merge_with_repos_set(repos_set_data)

# Extract config from AppConfig object
plugin_config = plugin_manager.get_plugin_config_from_app_config(
    'antimicrox',
    app_config
)
```

## Plugin Categories

- **MAPPERS**: Controller mapping tools (AntiMicroX, JoyToKey, etc.)
- **WINDOWING**: Window management (Borderless Gaming, etc.)
- **DISPLAY**: Display configuration (MultiMonitorTool, etc.)
- **AUDIO**: Audio management (SoundVolumeView, etc.)
- **DISCS**: Disc mounting (WinCDEmu, OSFMount, etc.)
- **SYNC**: Cloud sync tools (rclone, Ludusavi, etc.)
- **CUSTOM**: User-defined tools

## Testing

Run the test script:

```bash
python test_plugin_system.py
```

## Benefits

1. **Modularity**: Tools are self-contained and independent
2. **Extensibility**: Add new tools without modifying core code
3. **Maintainability**: Clear separation of concerns
4. **Testability**: Plugins can be tested in isolation
5. **Documentation**: Self-documenting through metadata and schemas
6. **Backward Compatibility**: Integrates with existing configuration system

## Future Enhancements

- Hot-reload for plugins
- Plugin marketplace/discovery
- Dependency management between plugins
- Plugin versioning and updates
- UI auto-generation from plugin schemas
- Plugin sandboxing and security
