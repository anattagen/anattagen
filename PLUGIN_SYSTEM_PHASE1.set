# Plugin System - Phase 1 Implementation Guide

## Overview

This document outlines Phase 1 of the plugin system refactoring for [RJ_PROJ]. The goal is to create a modular, extensible architecture that allows external tools to be integrated without modifying core code, while maintaining full backward compatibility.

## Architecture Goals

1. **Modularity**: Tools are self-contained plugins with clear interfaces
2. **Extensibility**: New tools can be added without touching core code
3. **Discoverability**: Automatic detection of installed tools
4. **Backward Compatibility**: Existing functionality remains unchanged
5. **Testability**: Plugins can be tested in isolation

## Core Components

### 1. Plugin Base Classes

**File**: `Python/plugins/base_plugin.py`

The foundation of the plugin system consists of:

#### ToolPlugin (Abstract Base Class)
```python
class ToolPlugin(ABC):
    """Base class for all tool plugins"""
    
    # Identity
    @property
    @abstractmethod
    def name(self) -> str:
        """Unique identifier (e.g., 'antimicrox')"""
    
    @property
    @abstractmethod
    def display_name(self) -> str:
        """Human-readable name (e.g., 'AntiMicroX')"""
    
    @property
    @abstractmethod
    def category(self) -> str:
        """Category: MAPPERS, WINDOWING, DISPLAY, etc."""
    
    # Discovery
    @abstractmethod
    def get_executable_patterns(self) -> List[str]:
        """Executable names to search for"""
    
    # Configuration
    def get_config_schema(self) -> Dict[str, ConfigField]:
        """Define required configuration fields"""
    
    # Command Building
    @abstractmethod
    def build_launch_command(self, config: PluginConfig) -> Optional[str]:
        """Build command for launch sequence"""
    
    def build_exit_command(self, config: PluginConfig) -> Optional[str]:
        """Build command for exit sequence"""
```

#### Supporting Data Structures
```python
@dataclass
class ConfigField:
    """Defines a configuration field"""
    name: str
    field_type: str  # 'file', 'directory', 'boolean', 'string'
    label: str
    required: bool = False
    default: Any = None
    filter: Optional[str] = None  # File filter (e.g., "*.amgp")

@dataclass
class PluginConfig:
    """Runtime configuration for a plugin"""
    tool_path: Optional[str] = None
    options: str = ""
    arguments: str = ""
    wait: bool = False
    enabled: bool = True
    custom_fields: Dict[str, Any] = field(default_factory=dict)
```

### 2. Plugin Registry

**File**: `Python/plugins/registry.py`

Central registry for managing all plugins:

```python
class PluginRegistry:
    """Central registry for all tool plugins"""
    
    def __init__(self):
        self.plugins: Dict[str, ToolPlugin] = {}
        self.categories: Dict[str, List[ToolPlugin]] = {}
    
    def register(self, plugin: ToolPlugin):
        """Register a plugin"""
        self.plugins[plugin.name] = plugin
        category = plugin.category
        if category not in self.categories:
            self.categories[category] = []
        self.categories[category].append(plugin)
    
    def get_plugin(self, name: str) -> Optional[ToolPlugin]:
        """Get plugin by name"""
        return self.plugins.get(name)
    
    def get_by_category(self, category: str) -> List[ToolPlugin]:
        """Get all plugins in a category"""
        return self.categories.get(category, [])
    
    def get_all_plugins(self) -> List[ToolPlugin]:
        """Get all registered plugins"""
        return list(self.plugins.values())
```

### 3. Plugin Manager

**File**: `Python/managers/plugin_manager.py`

High-level manager for plugin operations:

```python
class PluginManager:
    """Manages plugin lifecycle and tool discovery"""
    
    def __init__(self, bin_directory: str):
        self.registry = PluginRegistry()
        self.bin_directory = bin_directory
        self.installed_tools: Dict[str, List[str]] = {}
    
    def load_builtin_plugins(self):
        """Load built-in plugins from Python/plugins/builtin/"""
        # Auto-discover and register plugins
    
    def scan_for_installed_tools(self) -> Dict[str, List[str]]:
        """Scan bin directory for installed tools"""
        found = {}
        for plugin in self.registry.get_all_plugins():
            paths = self._find_executables(
                plugin.get_executable_patterns()
            )
            if paths:
                found[plugin.name] = paths
        return found
    
    def _find_executables(self, patterns: List[str]) -> List[str]:
        """Case-insensitive recursive search for executables"""
        # Implementation uses the case-insensitive logic
```

## Built-in Plugins

### Example: AntiMicroX Plugin

**File**: `Python/plugins/builtin/antimicrox_plugin.py`

```python
class AntiMicroXPlugin(ToolPlugin):
    @property
    def name(self) -> str:
        return "antimicrox"
    
    @property
    def display_name(self) -> str:
        return "AntiMicroX"
    
    @property
    def category(self) -> str:
        return "MAPPERS"
    
    def get_executable_patterns(self) -> List[str]:
        return ["antimicrox.exe", "AntiMicroX.exe"]
    
    def get_config_schema(self) -> Dict[str, ConfigField]:
        return {
            'player1_profile': ConfigField(
                name='player1_profile',
                field_type='file',
                label='Player 1 Profile',
                filter='*.amgp'
            ),
            'player2_profile': ConfigField(
                name='player2_profile',
                field_type='file',
                label='Player 2 Profile',
                filter='*.amgp'
            ),
            'mediacenter_profile': ConfigField(
                name='mediacenter_profile',
                field_type='file',
                label='Media Center Profile',
                filter='*.amgp'
            )
        }
    
    def build_launch_command(self, config: PluginConfig) -> Optional[str]:
        if not config.tool_path:
            return None
        
        p1 = config.custom_fields.get('player1_profile')
        if not p1:
            return None
        
        cmd = f'"{config.tool_path}"'
        if config.options:
            cmd += f' {config.options}'
        cmd += f' --tray --hidden --profile "{p1}"'
        if config.arguments:
            cmd += f' {config.arguments}'
        
        p2 = config.custom_fields.get('player2_profile')
        if p2:
            cmd += f' --next --profile-controller 2 --profile "{p2}"'
        
        return cmd
    
    def build_exit_command(self, config: PluginConfig) -> Optional[str]:
        if not config.tool_path:
            return None
        
        mc = config.custom_fields.get('mediacenter_profile')
        if not mc:
            return None
        
        cmd = f'"{config.tool_path}" --tray --hidden --profile "{mc}"'
        return cmd
```

### Example: Borderless Gaming Plugin

**File**: `Python/plugins/builtin/borderless_plugin.py`

```python
class BorderlessGamingPlugin(ToolPlugin):
    @property
    def name(self) -> str:
        return "borderless"
    
    @property
    def display_name(self) -> str:
        return "Borderless Gaming"
    
    @property
    def category(self) -> str:
        return "WINDOWING"
    
    def get_executable_patterns(self) -> List[str]:
        return [
            "borderless.exe",
            "borderlessgaming.exe",
            "BorderlessGaming.exe"
        ]
    
    def get_config_schema(self) -> Dict[str, ConfigField]:
        return {
            'terminate_on_exit': ConfigField(
                name='terminate_on_exit',
                field_type='boolean',
                label='Terminate on Exit',
                default=True
            )
        }
    
    def build_launch_command(self, config: PluginConfig) -> Optional[str]:
        if not config.tool_path:
            return None
        
        cmd = f'"{config.tool_path}"'
        if config.options:
            cmd += f' {config.options}'
        if config.arguments:
            cmd += f' {config.arguments}'
        
        return cmd
    
    def build_exit_command(self, config: PluginConfig) -> Optional[str]:
        # Borderless is typically killed, not restarted
        return None
```

## Integration with Existing Code

### Backward Compatibility Strategy

The plugin system is designed to coexist with the existing codebase:

1. **Parallel Systems**: Plugins run alongside existing hardcoded tools
2. **Gradual Migration**: Tools can be migrated one at a time
3. **Fallback Logic**: If plugin fails, fall back to legacy code
4. **Configuration Bridge**: Map existing config to plugin config

### Integration Points

#### 1. Setup Tab Integration

```python
# In Python/ui/setup_tab.py
class SetupTab(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Initialize plugin manager
        self.plugin_manager = PluginManager(
            os.path.join(constants.APP_ROOT_DIR, 'bin')
        )
        self.plugin_manager.load_builtin_plugins()
        
        # Scan for installed tools
        self.installed_tools = self.plugin_manager.scan_for_installed_tools()
        
        # Existing code continues...
```

#### 2. Sequence Executor Integration

```python
# In Python/sequence_executor.py
class SequenceExecutor:
    def __init__(self, launcher):
        self.launcher = launcher
        self.plugin_manager = getattr(launcher, 'plugin_manager', None)
        
        # Existing action map
        self.actions = {
            'Controller-Mapper': self._run_controller_mapper_with_plugin,
            # ... other actions
        }
    
    def _run_controller_mapper_with_plugin(self):
        """Try plugin first, fall back to legacy"""
        if self.plugin_manager:
            plugin = self.plugin_manager.registry.get_plugin('antimicrox')
            if plugin:
                config = self._build_plugin_config(plugin)
                cmd = plugin.build_launch_command(config)
                if cmd:
                    self.launcher.run_process(cmd)
                    return
        
        # Fallback to legacy implementation
        self._run_controller_mapper_legacy()
```

#### 3. Widget Population

```python
# In Python/ui/widgets.py
class PathConfigRow(QWidget):
    def __init__(self, config_key, plugin_manager=None, **kwargs):
        super().__init__(**kwargs)
        self.plugin_manager = plugin_manager
        
        # If plugin manager available, use it for discovery
        if self.plugin_manager and repo_items:
            self._populate_from_plugins()
        else:
            # Existing population logic
            self._populate_legacy()
    
    def _populate_from_plugins(self):
        """Populate combobox using plugin system"""
        installed = self.plugin_manager.installed_tools
        for plugin_name, paths in installed.items():
            for path in paths:
                if self.combo.findText(path) == -1:
                    self.combo.addItem(path)
```

## Testing

### Unit Tests

**File**: `test_plugin_system.py`

```python
import unittest
from Python.plugins.registry import PluginRegistry
from Python.plugins.builtin.antimicrox_plugin import AntiMicroXPlugin

class TestPluginSystem(unittest.TestCase):
    def setUp(self):
        self.registry = PluginRegistry()
        self.plugin = AntiMicroXPlugin()
    
    def test_plugin_registration(self):
        self.registry.register(self.plugin)
        self.assertIn('antimicrox', self.registry.plugins)
    
    def test_command_building(self):
        config = PluginConfig(
            tool_path='C:/bin/antimicrox.exe',
            custom_fields={
                'player1_profile': 'C:/profiles/p1.amgp'
            }
        )
        cmd = self.plugin.build_launch_command(config)
        self.assertIn('--profile', cmd)
        self.assertIn('p1.amgp', cmd)
    
    def test_category_filtering(self):
        self.registry.register(self.plugin)
        mappers = self.registry.get_by_category('MAPPERS')
        self.assertEqual(len(mappers), 1)
        self.assertEqual(mappers[0].name, 'antimicrox')
```

### Integration Tests

```python
def test_tool_discovery():
    """Test that installed tools are found"""
    manager = PluginManager('bin')
    manager.load_builtin_plugins()
    found = manager.scan_for_installed_tools()
    
    # Should find antimicrox if installed
    if os.path.exists('bin/AntiMicroX/bin/antimicrox.exe'):
        assert 'antimicrox' in found
```

## Migration Path

### Phase 1: Foundation (Current)
- ✅ Create plugin base classes
- ✅ Implement registry system
- ✅ Create plugin manager
- ✅ Implement 2-3 example plugins
- ✅ Write unit tests

### Phase 2: Integration (Next)
- [ ] Integrate plugin manager into SetupTab
- [ ] Update sequence executor to use plugins
- [ ] Migrate PathConfigRow to use plugin discovery
- [ ] Add plugin-based UI generation
- [ ] Comprehensive integration testing

### Phase 3: Migration (Future)
- [ ] Migrate all hardcoded tools to plugins
- [ ] Remove legacy code paths
- [ ] Add plugin hot-reload capability
- [ ] Create plugin development documentation

### Phase 4: Advanced Features (Future)
- [ ] Plugin marketplace/discovery
- [ ] Third-party plugin support
- [ ] Plugin dependency management
- [ ] Plugin versioning system

## File Structure

```
[RJ_PROJ]/
├── Python/
│   ├── plugins/
│   │   ├── __init__.py
│   │   ├── base_plugin.py          # Abstract base classes
│   │   ├── registry.py             # Plugin registry
│   │   └── builtin/                # Built-in plugins
│   │       ├── __init__.py
│   │       ├── antimicrox_plugin.py
│   │       ├── borderless_plugin.py
│   │       ├── multimonitor_plugin.py
│   │       └── ...
│   ├── managers/
│   │   ├── plugin_manager.py       # Plugin lifecycle management
│   │   └── ...
│   └── ...
├── assets/
│   └── plugins/                    # Future: External plugin manifests
│       └── ...
├── test_plugin_system.py           # Unit tests
└── PLUGIN_SYSTEM_PHASE1.md         # This document
```

## Benefits Realized

### 1. Modularity
- Each tool is self-contained
- Clear separation of concerns
- Easy to understand and maintain

### 2. Extensibility
- New tools can be added by creating a plugin class
- No need to modify core code
- Third-party developers can create plugins

### 3. Discoverability
- Automatic detection of installed tools
- Case-insensitive file matching
- Recursive directory scanning

### 4. Testability
- Plugins can be tested in isolation
- Mock configurations easily
- Clear interfaces for testing

### 5. Maintainability
- Reduced code duplication
- Centralized tool management
- Easier debugging

## Usage Examples

### Creating a New Plugin

```python
# Python/plugins/builtin/mytool_plugin.py
from Python.plugins.base_plugin import ToolPlugin, ConfigField, PluginConfig
from typing import List, Dict, Optional

class MyToolPlugin(ToolPlugin):
    @property
    def name(self) -> str:
        return "mytool"
    
    @property
    def display_name(self) -> str:
        return "My Tool"
    
    @property
    def category(self) -> str:
        return "UTILITIES"
    
    def get_executable_patterns(self) -> List[str]:
        return ["mytool.exe", "MyTool.exe"]
    
    def get_config_schema(self) -> Dict[str, ConfigField]:
        return {
            'config_file': ConfigField(
                name='config_file',
                field_type='file',
                label='Configuration File',
                filter='*.cfg'
            )
        }
    
    def build_launch_command(self, config: PluginConfig) -> Optional[str]:
        if not config.tool_path:
            return None
        
        cmd = f'"{config.tool_path}"'
        
        cfg = config.custom_fields.get('config_file')
        if cfg:
            cmd += f' --config "{cfg}"'
        
        if config.options:
            cmd += f' {config.options}'
        
        return cmd
```

### Using the Plugin System

```python
# Initialize
plugin_manager = PluginManager('bin')
plugin_manager.load_builtin_plugins()

# Discover installed tools
installed = plugin_manager.scan_for_installed_tools()
print(f"Found tools: {list(installed.keys())}")

# Get a specific plugin
plugin = plugin_manager.registry.get_plugin('antimicrox')

# Build configuration
config = PluginConfig(
    tool_path='C:/bin/AntiMicroX/bin/antimicrox.exe',
    options='--tray',
    custom_fields={
        'player1_profile': 'C:/profiles/player1.amgp'
    }
)

# Generate command
cmd = plugin.build_launch_command(config)
print(f"Command: {cmd}")

# Execute
subprocess.run(cmd, shell=True)
```

## Next Steps

1. **Review and Test**: Thoroughly test the plugin system with existing tools
2. **Integration**: Begin integrating into SetupTab and SequenceExecutor
3. **Documentation**: Create developer guide for plugin creation
4. **Migration**: Start migrating hardcoded tools to plugins
5. **Community**: Prepare for third-party plugin support

## Conclusion

Phase 1 establishes a solid foundation for a modular, extensible plugin architecture. The system is designed to coexist with existing code, allowing for gradual migration without breaking changes. The plugin system provides clear benefits in terms of maintainability, testability, and extensibility, positioning [RJ_PROJ] for future growth and community contributions.

## References

- `Python/plugins/base_plugin.py` - Plugin base classes
- `Python/plugins/registry.py` - Plugin registry
- `Python/managers/plugin_manager.py` - Plugin manager
- `Python/plugins/builtin/` - Example plugin implementations
- `test_plugin_system.py` - Unit tests

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-13  
**Status**: Phase 1 Complete, Ready for Phase 2
